00001000
00001000 00010100001000000000000000001000
00001001 00010100010000000000000000010000
00001002 01001000011000110000000000000000
00001003 01001000100001000000000000000000
00001004 00010100101000000000000000000001
00001005 10000100000000000001000000001010
00001006 11111111111111111111111111111111
0000100A 00110000010000100000000000000001
0000100B 00000000011000100000000000000000
0000100C 00100000100001000001100000000000
0000100D 00110000101001010000000000000001
0000100E 10110111111001010000111111111011
0000100F 01100100100000000001100000000000
00001010 10001000000000000000000000000000

Data mem:
00000002	00000000000000000000000000001111
00000003	00000000000000000000000000000001
00000011    00000000000000000000000000000011
00000012    00000000000000000000000000000100
00000013    00000000000000000000000000000101
00000014    00000000000000000000000000000110
00000015    00000000000000000000000000000111
00000016    00000000000000000000000000000001
00000017    00000000000000000000000000001001
00000018    00000000000000000000000000000101

1000
movi r1 #0x08    // r1=8  broj brojeva koji se sabiraju, cija se sredina trazi
movi r2 #0x10    // r2=16 adresa u data memoriji
xor r3 r3 r3     // r3=0  pomocni registar za cuvanje trenutnog broja
xor r4 r4 r4     // r4=0  konacan rezultat
movi r5 #1       // r5=1 brojac
jsr 100A
halt

100A
add  r2, r2, r5   // uvecavamo adresu za brojac
load r3, r2, #0   // r3=mem[r2] citamo podatak u r3
add  r4 r4 r3	  // r4=r4+r3 inc sume
addi r5 r5 #1     // inc brojaca
ble  r5 r1 -5     // ako je r5>r1 onda smo stigli do kraja, ne vracamo se
shr r4, #3        // pomeranje r4 za 3 mesta udesno, delimo sa 8
rts   

rezultat u R4 = 5